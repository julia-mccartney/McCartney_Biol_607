---
author: "Julia"
date due: "10/9/2020"
output: html_document
---

# Homework 4: Functions and Tidy Data {.tabset}

#### Julia McCartney  
#### Due 10/9/2020

This homework's file can also be found on [Github](https://github.com/julia-mccartney/McCartney_Biol_607/blob/master/homework/04_McCartney_Julia_2020.Rmd)

  
  Libraries Used
```{r Libraries, message = FALSE}
library(dplyr)
library(purrr)
library(formattable)
library(lubridate)
library(ggplot2)
library(tidyr)
```



## 1. Write a function
Write a function that takes a vector and returns one bootstrapped sample from said vector. Demonstrate that it works.

```{r 1}
# Write a function to sample a vector with replacement
bootsamp <- function(vec, L = length(vec)){ # take a vector
  bootsamp <- sample(vec, L, replace = TRUE) # bootstrap a sample
  return(bootsamp)
}
myvec <- c(3,5,2,1,2,3,5,6,8,7) # create a test vector

bootsamp(myvec, L = 20) # test the function

```


## 2. Write another function
Write a function that given a vector of values, a request for some number of bootstraps (let’s call the parameter R), and a sample statistic function (e.g., mean, IQR, etc.) returns R number of values of that statistic. 
Have it default to R = 1000 and the function is mean. Show this works for 10 bootstrapped replicate draws of a mean from some vector. Do the values look reasonable? Compare to the actual mean of the vector. Make sure you are using the function(s) you wrote in #1

```{r 2}
bootstats_mean <- function(vec, R = 1000, L = length(vec), stat = mean) {# given a vector
  stat_out <- replicate(R, # bootstrap some number of times
          stat(bootsamp(vec, L))) # get a statistic - it is generalized to work for many stats!
  return(stat_out)
}

bootstats_mean(myvec, R = 10, stat = mean) # test the function
mean(myvec) # compare to the mean of the vector

```


## 3. Write yet another function
Write a function that, given a vector of values a request for some number of bootstraps, and a sample statistic function, returns the original value of the statistic as applied to the vector, the mean of the statistic generated by the bootstrapped reps, the upper and lower 95% CI of the bootstrapped statistic (e.g., the 0.025 and 0.975 quantile), and the bias (i.e., the original value of the statistic - the mean of the bootstrapped statistic). 
Make sure you are using the function(s) you wrote in #1 and/or #2


```{r 3, message = FALSE}
# write a function to calculate a some basic stats from bootstrapped values (bias, CI, original stat, mean of stat)

bootstats_info <- function(vec, R, L = length(myvec),stat = mean){
#given a vector
#bootstrap some number of times

#Load needed dep
  
# calculate original stat
og_stat <- stat(vec)
# calculate some stat
s <- bootstats_mean(vec, R, L, stat) 

# calculate the mean of said stat
m_s <- mean(s)

# calculate upper and lower 95% CI of stat 

ci_u <- quantile(s, probs = c(0.975))
ci_l <- quantile(s, probs = c(0.025))

# calculate bias
bias <- og_stat - s


df <- data.frame("Bootstrapped_Statistic" = s,
                 "Original Statistic" = og_stat,
                 "Mean_of_the_Bootstrapped_Value" = m_s,
                 "UCI" = ci_u,
                 "LCI" = ci_l,
                 "Bias" = bias)
return(df)
  
}

# test the function

formattable(bootstats_info(myvec, R = 10, stat = mean))

```


## 4. Looking at polling data
FiveThirtyEight keeps a great archive of poll data at https://projects.fivethirtyeight.com/polls/. The presidential general election polling data is freely available at https://projects.fivethirtyeight.com/polls-page/president_polls.csv with question, poll id, and cycle defining a unique poll.

### 4a. Download and look at the data. Is it long or wide?

```{r 4a}
# download data from FiveThirtyEight
pres_polls <- read.csv("https://projects.fivethirtyeight.com/polls-page/president_polls.csv")

# view the data
formattable(head(pres_polls))
```
The data is in long format

### 4b. Get just the polling data for this last week (from 9/29 to today). 
Filter on start_date. Also filter down to just Biden and Trump (see candidate_name or answer). Extra credit for using {lubridate} for this, but you can just do a messy %in% string match.

```{r 4b}
# pull most recent data (Sept 29 to Oct 6)

pres_polls$start_date <- mdy(pres_polls$start_date) # change to date format

recent_polls <- pres_polls %>% 
  filter(start_date >= as_date("2020-09-29"),
         answer == "Biden" | answer == "Trump") # create df including only recent polls

```



### 4c. OK, this is your sample. What’s the bootstrapped average percentage for each candidate for nationwide polls (state == "")? 
Note, this answer will not match 538 given their weighting by poll trustworthiness.

```{r 4c, message = FALSE}
# Create a graph looking at av polling per candidate 

#set up color scheme
party_colors <- c(DEM = "blue", REP = "red", Biden = "blue", Trump = "red") 

# graph
recent_polls %>% 
  filter(state == "") %>% 
  group_by(candidate_name, candidate_party) %>% 
  summarize(
    av_poll = replicate(1000,
                        sample(pct, size = 100, replace = TRUE)) %>% 
                        mean) %>% 
  ungroup() %>% 
  ggplot(aes(y = candidate_name, x = av_poll, fill = candidate_party)) +
  geom_col() + 
  scale_fill_manual(values = party_colors)+
  labs(y = "Candidate",
       x = "Average Poll Result (%)",
       fill = "Party") +
  theme_minimal()

```

### 4d. What is the average difference between the two candidates by state and national polls? 
Note, you’ll need to make this a wide data frame to answer! And, well, try the pivot without this advice first, but then… make a unique ID by pasting together the question_id, poll_id, and state. Then select the ID, state, answer, and pct. Also filter out NA diffs

```{r 4d, message = FALSE}
# calculate the av. difference in polling % between Biden and Trump by state based off of bootstrapped difs

recent_polls_top <- recent_polls %>% 
  filter(answer == "Biden" | answer == "Trump") %>% 
  mutate(ID = paste(question_id,poll_id,state, sep = "_")) %>% 
  select(ID, state, answer, pct) %>% 
  pivot_wider(names_from = answer, values_from = pct) %>% 
  mutate(state = case_when(state == "" ~"National", 
                           TRUE ~ state)) %>%  # this was just bothering me
  na.omit(na.rm = TRUE) %>% 
  mutate(dif = (Biden - Trump)) %>% 
  group_by(state) %>% 
  summarize(
    "Biden-Trump Av Difference" = replicate(1000,
                        sample(dif, size = 100, replace = TRUE)) %>% 
                        mean)

formattable(recent_polls_top)
          
```


## 5. Working with replicate()

`replicate()` has been our friend, but we’ve always had to be a little hacky with it. We’ve either had to fold in means, or use tricksy functions like colMeans and the like.

BUT - what’s interesting about replicate() is that, if you ask it to turn back raw draws from a random number generator - or anything with more than one value - it gives you a matrix or array.

### 5a. So, I want you to, using the mean and SD of Biden’s national polling average (you’ll need to calculate it!) from above, simulate 1000 draws from that population with a sample size of 50. 
What are the dimensions of the object? What are in the rows and columns?

```{r 5a}
# Calculate parameters for simulation
Biden_filter <- recent_polls %>% 
  filter(state == "", answer == "Biden") 

# simulate for boots
Biden_boot <- replicate(1000, rnorm(50, 
                                  mean = mean(Biden_filter$pct)),
                      sd(Biden_filter$pct))

class(Biden_boot)

dim(Biden_boot)


```

The object that comes directly out of the bootstrap is an object with class "matrix" and "array". It has dimensions of 50 rows and 1000 columns (this 1000 replicates of the sample)

### 5b. Yuck. Can you turn this into something usable? 
Say, first make it a tibble or data frame, and then pivot it to long, such that you end up with a column that has an identifier for sim and a column with a single value from that sim?  
(Oh, and for all columns, cols = everything())

```{r 5b}
# Create a data frame and put data into long format by sim
Biden_boot_Long <- as.data.frame(Biden_boot) %>% 
  pivot_longer(cols = everything(),
               names_to = "sim",
               values_to = "values")

formattable(head(Biden_boot_Long))
```



### 5c. For each sim, what’s the bootsrapped mean and CI? 
Plot it! And tell us how often it’s greater than the initial mean. E.C. for the plot showing the stats in order from low to high.

```{r 5c, message = FALSE}
# calculate Mean and CIs by simulation
Biden_boot_Long2 <- Biden_boot_Long %>% 
  group_by(sim) %>% 
  summarise("LCI" = quantile(values,probs = 0.025),
            "UCI" = quantile(values,probs = 0.975),
            "Mean" = mean(values))

```

```{r 5c Plot}
# graph bootstrapped biden national means, show CIs and actual mean
ggplot(Biden_boot_Long2, aes(y = Mean, x = reorder(sim, Mean))) + 
  geom_pointrange(aes(ymin=LCI, ymax = UCI), color = "steelblue") +
  geom_point()+
  geom_jitter()+
  theme_minimal() +
  theme(axis.text.x = element_blank()) + 
  scale_color_discrete() +
  labs(y = "Average Percent",
       x = "Simulation") +
  geom_hline(yintercept = mean(Biden_filter$pct), color = "red")

```
In this plot, the blue lines are the confidence intervals, the black dots are the mean, and the red line is the actual mean of the national polls. The simulated mean is greater than the initial mean in approximately half of all simulations (mean is well centered in simulation distribution)

### 5d. So…. what is that plot showing? What are the concepts involved?

This plot is showing that the mean is has low variation (ranges less than 2%) and is very close to the original mean. We expect this as the simulations were drawn from a normal distribution (centered around the mean). It is also showing that the sample is of an appropriate size, as the confidence intervals are relatively small across simulations (appears to range at most 4% for a single sample, collectively ranging between ~48-54%). Larger sample sizes will result in smaller confidence intervals.



